import { readFileSync, writeFileSync } from 'fs';
import { ensureDirSync } from 'fs-extra';
import { join, dirname, resolve, relative } from 'pathe';
import { createUtils } from '@windicss/plugin-utils';
import { resolveModule, defineNuxtModule, clearRequireCache, isNuxt3, isNuxt2, tryRequireModule, requireModule, extendWebpackConfig, extendViteConfig, createResolver } from '@nuxt/kit';
import { loadConfiguration } from '@windicss/config';
import VitePluginWindicss from 'vite-plugin-windicss';
import defu, { defu as defu$1 } from 'defu';
import consola from 'consola';
import { createApp, fromNodeMiddleware, toNodeListener } from 'h3';
import { ApiMiddleware } from 'windicss-analysis';
import { listen } from 'listhen';
import sirv from 'sirv';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const version = "2.6.0";

const logger = consola.withScope("nuxt-windicss");

async function analyze(runtime, options = {}) {
  if (typeof options === "boolean")
    options = {};
  const resolvedOptions = defu(options, {
    server: {
      port: 3330,
      showURL: false
    }
  });
  const app = createApp();
  app.use("/api", fromNodeMiddleware(ApiMiddleware(runtime.windiOptions, { utils: runtime.utils, ...resolvedOptions.analysis })));
  app.use(
    fromNodeMiddleware(sirv(
      join(dirname(resolveModule("windicss-analysis")), "app"),
      { dev: true, single: true }
    ))
  );
  return await listen(toNodeListener(app), resolvedOptions.server);
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-windicss",
    configKey: "windicss",
    compatibility: {
      nuxt: "^2.0.0 || ^3.0.0"
    }
  },
  defaults(nuxt) {
    return {
      analyze: false,
      displayVersionInfo: true,
      scan: {
        dirs: [
          nuxt.options.srcDir
        ],
        exclude: [
          nuxt.options.buildDir,
          "node_modules",
          "node_modules_dev",
          "node_modules_prod",
          "dist",
          ".git",
          ".github",
          ".output",
          ".nuxt",
          "coverage",
          "**/__snapshots__",
          "*.test.js"
        ]
      },
      preflight: {
        alias: {
          "nuxt-link": "a",
          "nuxt-img": "img"
        }
      },
      transformCSS: "pre"
    };
  },
  async setup(options, nuxt) {
    const nuxtOptions = nuxt.options;
    if (!options.root)
      options.root = nuxt.options.rootDir;
    const installedModules = [
      ...nuxt.options.modules,
      ...nuxt.options.buildModules || []
    ];
    if (installedModules.includes("@nuxtjs/tailwindcss")) {
      logger.error("Sorry, you can't use Windi CSS with Tailwind CSS. Please remove the `@nuxtjs/tailwindcss` module.");
      return;
    }
    if (options.scan && nuxt.options._layers?.length > 1) {
      options.scan = options.scan === true ? {} : options.scan;
      if (typeof options.scan.dirs === "string")
        options.scan.dirs = [options.scan.dirs];
      if (typeof options.scan.exclude === "string")
        options.scan.exclude = [options.scan.exclude];
      const nonSrcLayers = nuxtOptions._layers.filter((l) => l.cwd !== nuxt.options.srcDir);
      options.scan.dirs?.push(...nonSrcLayers.map((l) => l.cwd || ""));
      const originalExclude = options.scan.exclude;
      options.scan.exclude?.push(...nonSrcLayers.map((l) => originalExclude.map((p) => resolve(l.cwd || "", p))).flat());
    }
    const ctxOnOptionsResolved = options.onOptionsResolved;
    options.onOptionsResolved = async (options2) => {
      if (ctxOnOptionsResolved) {
        const result = ctxOnOptionsResolved(options2);
        return typeof result === "object" ? result : options2;
      }
      await nuxt.callHook("windicss:options", options2);
      logger.debug("Post hook windicss:options", options2);
      return options2;
    };
    const ctxOnConfigResolved = options.onConfigResolved;
    let passed = false;
    options.onConfigResolved = async (windiConfig, configFilePath) => {
      if (!passed) {
        let configType = "inline";
        if (configFilePath) {
          clearRequireCache(configFilePath);
          configType = `./${relative(nuxtOptions.rootDir, configFilePath)}`;
          if (nuxt.options.dev && nuxt.options.watch)
            nuxt.options.watch.push(configFilePath);
        }
        if (nuxt.options._layers?.length > 1) {
          nuxtOptions._layers.filter((l) => l.cwd !== nuxt.options.srcDir).forEach((l) => {
            const { config, filepath } = loadConfiguration({
              onConfigurationError: (error) => console.error(error),
              onConfigurationNotFound: () => {
              },
              root: l.cwd
            });
            if (!filepath || !config)
              return;
            if (nuxt.options.dev && nuxt.options.watch)
              nuxt.options.watch.push(filepath);
            windiConfig = defu$1(windiConfig, config);
          });
        }
        if (options.displayVersionInfo && nuxt.options.dev) {
          nuxt.hook("build:before", () => {
            logger.info(`\`nuxt-windicss v${version}\` running with config: \`${configType}\`.`);
          });
        }
        passed = true;
      }
      if (ctxOnConfigResolved) {
        const result = await ctxOnConfigResolved(windiConfig, configFilePath);
        return typeof result === "object" ? result : windiConfig;
      }
      await nuxt.callHook("windicss:config", windiConfig);
      logger.debug("Post hook windicss:config", windiConfig);
      return windiConfig;
    };
    const utils = createUtils(options, { root: options.root, name: "nuxt-windicss" });
    const ensureInit = utils.init().then(() => nuxt.callHook("windicss:utils", utils));
    const windiImports = nuxt.options.css.filter(
      (css) => (typeof css === "string" ? css : css.src).includes("virtual:windi")
    );
    if (!windiImports.length)
      nuxt.options.css.unshift("virtual:windi.css");
    if (isNuxt3(nuxt) && nuxt.options.vite === false) {
      nuxt.options.css = nuxt.options.css.map((css) => {
        if (!css.includes("virtual:windi") || css.startsWith("@"))
          return css;
        return join("@", css);
      });
    }
    if (isNuxt2(nuxt)) {
      nuxt.hook("build:templates", ({ templateVars, templatesFiles }) => {
        templateVars.css = templateVars.css.map((css) => {
          const src = typeof css === "string" ? css : css.src;
          if (src.includes("virtual:windi")) {
            return {
              src,
              virtual: true
            };
          }
          return css;
        });
        templatesFiles.map((template) => {
          if (!template.src.endsWith("App.js"))
            return template;
          const file = readFileSync(template.src, { encoding: "utf-8" });
          const regex = /(import '<%= )(relativeToBuild\(resolvePath\(c\.src \|\| c, { isStyle: true }\)\))( %>')/gm;
          const subst = "$1c.virtual ? c.src : $2$3";
          const appTemplate = file.replace(regex, subst);
          ensureDirSync(join(__dirname, "runtime"));
          const newPath = join(__dirname, "runtime", "App.js");
          writeFileSync(newPath, appTemplate);
          template.src = newPath;
          return template;
        });
      });
    }
    nuxt.hook("build:before", async () => {
      const nuxtPostcss = nuxt.options.postcss || nuxt.options.build.postcss.postcssOptions || nuxt.options.build.postcss;
      if (!nuxtPostcss)
        return;
      const hasPostCSSImport = tryRequireModule("postcss-import");
      if (!hasPostCSSImport)
        return;
      const readCache = requireModule("read-cache");
      const updatedPostcssImport = {
        async load(filename) {
          await ensureInit;
          const file = await readCache(filename, "utf-8");
          return utils.transformCSS(file, filename);
        }
      };
      nuxtPostcss.plugins = nuxtPostcss.plugins || {};
      nuxtPostcss.plugins["postcss-import"] = {
        ...nuxtPostcss.plugins["postcss-import"],
        ...updatedPostcssImport
      };
    });
    extendWebpackConfig((config) => {
      const WindiCSSWebpackPlugin = requireModule("windicss-webpack-plugin");
      const plugin = new WindiCSSWebpackPlugin({ ...options, utils });
      config.plugins = config.plugins || [];
      config.plugins.push(plugin);
    });
    extendViteConfig(async (config) => {
      const plugin = VitePluginWindicss(options, { root: options.root, utils, name: "nuxt-windicss" });
      nuxt.options.alias["windi.css"] = "virtual:windi.css";
      config.plugins = config.plugins || [];
      config.plugins.unshift(...plugin);
    });
    if (nuxtOptions.dev) {
      if (installedModules.includes("@nuxt/content")) {
        if (isNuxt2(nuxt)) {
          nuxt.hook("content:file:beforeParse", async (file) => {
            if (file.extension !== ".md")
              return;
            await ensureInit;
            await utils.extractFile(file.data, file.path, true);
            const css = await utils.generateCSS();
            file.data += `

<style>${css}</style>`;
          });
        } else {
          await ensureInit;
          const { resolve: resolve2 } = createResolver(import.meta.url);
          const resolveRuntimeModule = (path) => resolveModule(path, { paths: resolve2("./runtime") });
          nuxt.hooks.hook("nitro:config", (nitroConfig) => {
            nitroConfig.externals = defu$1(typeof nitroConfig.externals === "object" ? nitroConfig.externals : {}, {
              inline: [
                resolve2("./runtime")
              ]
            });
            nitroConfig.alias["#windicss/transformer"] = resolveRuntimeModule("./server/class-extractor");
            nitroConfig.virtual = nitroConfig.virtual || {};
            nitroConfig.virtual["#windicss/config"] = `export default ${JSON.stringify({
              ...utils.options.config,
              plugins: []
            })}`;
            nitroConfig.plugins = nitroConfig.plugins || [];
            nitroConfig.plugins.push("#windicss/transformer");
          });
        }
      }
      if (options.analyze !== false) {
        let serverStarted = false;
        nuxt.hook("listen", () => {
          serverStarted = true;
        });
        analyze({
          windiOptions: options,
          utils
        }, options.analyze).then((server) => {
          const message = `WindiCSS Analysis: ${server.url}`;
          if (isNuxt3(nuxt)) {
            logger.info(message);
          } else if (serverStarted) {
            nuxt.hook("build:done", () => {
              serverStarted = true;
              logger.info(message);
            });
          } else {
            nuxt.options.cli.badgeMessages.push(message);
          }
        });
      }
    }
  }
});

export { module as default };
