import { createUtils } from '@windicss/plugin-utils';
import { resolve as resolve$1, join } from 'pathe';
import VirtualModulesPlugin from 'webpack-virtual-modules';
import { D as DEFAULT_SERVER_HOST, a as DEFAULT_SERVER_PORT, b as DEVTOOLS_POST_PATH, i as isDev, g as getChangedModuleNames, c as DEVTOOLS_VIRTUAL_MODULE, M as MODULE_ID, d as MODULE_ID_VIRTUAL_MODULES, e as DEVTOOLS_MODULE_ID, f as DEVTOOLS_VIRTUAL_MODULE_ID, h as debug, j as MODULE_ID_VIRTUAL_TEST, N as NAME, k as def } from './shared/windicss-webpack-plugin.c33fb8ee.mjs';
import http from 'http';
import { resolve } from 'path';
import 'debug';



// -- Unbuild CommonJS Shims --
import __cjs_url__ from 'url';
import __cjs_path__ from 'path';
import __cjs_mod__ from 'module';
const __filename = __cjs_url__.fileURLToPath(import.meta.url);
const __dirname = __cjs_path__.dirname(__filename);
const require = __cjs_mod__.createRequire(import.meta.url);
const getPort = (options) => import('get-port').then(({ default: getPort2 }) => getPort2(options));
function getBodyJson(req) {
  return new Promise((resolve2, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve2(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
function updateCSS(compiler) {
  const names = getChangedModuleNames(compiler.$windi);
  compiler.$windi.dirty.add(resolve(__dirname, "./core/dev-tools-update.js"));
  compiler.$windi.invalidateCssModules(DEVTOOLS_VIRTUAL_MODULE, names);
}
class Server {
  constructor(compiler, options) {
    var _a, _b;
    this.host = (_a = options == null ? void 0 : options.host) != null ? _a : DEFAULT_SERVER_HOST;
    this.port = (_b = options == null ? void 0 : options.port) != null ? _b : DEFAULT_SERVER_PORT;
    this.server = http.createServer(async (req, res) => {
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type");
      if (req.url === DEVTOOLS_POST_PATH && req.method === "POST") {
        try {
          const data = await getBodyJson(req);
          let changed = false;
          switch (data.type) {
            case "add-classes":
              changed = compiler.$windi.addClasses(data.data || []);
          }
          if (changed && this._listen)
            updateCSS(compiler);
          res.statusCode = 200;
          res.end();
        } catch (err) {
          res.statusCode = 500;
          res.end();
        }
      } else {
        res.statusCode = 200;
        res.end();
      }
    });
    this._listen = false;
  }
  async ensureStart() {
    if (!this._listen && isDev()) {
      this.port = await getPort({ port: this.port });
      this.server.listen(this.port, this.host, () => {
        this._listen = true;
        process.once("exit", () => {
          this.close();
        });
      });
    }
    return this;
  }
  close() {
    if (this._listen)
      this.server.close();
  }
}

const loadersPath = resolve$1(__dirname, "loaders");
const pitcher = resolve$1(loadersPath, "windicss-style-pitcher.cjs");
const transformCSSLoader = resolve$1(loadersPath, "windicss-css.cjs");
const transformTemplateLoader = resolve$1(loadersPath, "windicss-template.cjs");
const virtualModuleLoader = resolve$1(loadersPath, "virtual-module.cjs");
const devtoolsLoader = resolve$1(loadersPath, "dev-tools.cjs");
class WindiCSSWebpackPlugin {
  constructor(options = {}) {
    this.options = {
      ...{
        virtualModulePath: ""
      },
      ...options
    };
  }
  apply(compiler) {
    let root = compiler.context;
    if (this.options.root)
      root = this.options.root;
    else if (compiler.options.resolve && compiler.options.resolve.alias && compiler.options.resolve.alias["~"])
      root = compiler.options.resolve.alias["~"];
    if (!compiler.options.module || !compiler.options.module.rules)
      return;
    if (!compiler.options.resolve)
      compiler.options.resolve = {};
    compiler.options.resolve.alias = {
      ...compiler.options.resolve.alias,
      [join(this.options.virtualModulePath, MODULE_ID)]: resolve$1(compiler.context, MODULE_ID_VIRTUAL_MODULES[0]),
      [join(this.options.virtualModulePath, DEVTOOLS_MODULE_ID)]: resolve$1(compiler.context, DEVTOOLS_VIRTUAL_MODULE),
      [join(this.options.virtualModulePath, DEVTOOLS_VIRTUAL_MODULE_ID)]: resolve$1(compiler.context, DEVTOOLS_VIRTUAL_MODULE),
      ...MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
        map[join(this.options.virtualModulePath, key)] = resolve$1(compiler.context, key);
        return map;
      }, {}),
      ...MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
        map[join(this.options.virtualModulePath, key.replace("virtual:", ""))] = resolve$1(compiler.context, key);
        return map;
      }, {})
    };
    debug.plugin("options", this.options);
    compiler.options.module.rules = compiler.options.module.rules.map((rule) => {
      if (!rule.use || !Array.isArray(rule.use))
        return rule;
      rule.use = rule.use.map((use) => {
        if (use === "css-loader") {
          return {
            loader: "css-loader",
            options: {
              importLoaders: 2
            }
          };
        }
        return use;
      });
      return rule;
    });
    const shouldExcludeResource = (resource) => MODULE_ID_VIRTUAL_TEST.test(resource);
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isDetectTarget(resource));
      },
      resourceQuery: /type=style/,
      enforce: "post",
      use: [{
        loader: pitcher
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isDetectTarget(resource));
      },
      use: [{
        loader: transformTemplateLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isCssTransformTarget(resource));
      },
      use: [{
        loader: transformCSSLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        return MODULE_ID_VIRTUAL_TEST.test(resource);
      },
      enforce: "pre",
      use: [{
        loader: virtualModuleLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        return resource.includes(DEVTOOLS_VIRTUAL_MODULE);
      },
      enforce: "pre",
      use: [{
        loader: devtoolsLoader
      }]
    });
    compiler.hooks.afterCompile.tap(NAME, (compilation) => {
      if (!compiler.$windi)
        return;
      if (compiler.$windi.configFilePath) {
        const configFilePath = resolve$1(compiler.$windi.configFilePath);
        debug.plugin("config dependency at", configFilePath);
        compilation.fileDependencies.add(configFilePath);
      } else {
        for (const name of ["windi.config.ts", "windi.config.js"]) {
          const path = resolve$1(root, name);
          debug.plugin("setting watcher for config creation", path);
          compilation.missingDependencies.add(path);
        }
      }
    });
    const virtualModules = new VirtualModulesPlugin(
      [...MODULE_ID_VIRTUAL_MODULES, DEVTOOLS_VIRTUAL_MODULE].reduce((map, key) => {
        map[join(this.options.virtualModulePath, key)] = `/* ${key}(boot) */`;
        return map;
      }, {})
    );
    virtualModules.apply(compiler);
    let hmrId = 0;
    const invalidateCssModules = (resource, modules) => {
      const moduleUpdateId = hmrId++;
      modules.forEach((virtualModulePath) => {
        let virtualModuleContent = "";
        const match = virtualModulePath.match(MODULE_ID_VIRTUAL_TEST);
        if (match) {
          const layer = match[1] || "all";
          if (compiler.$windi && compiler.$windi.virtualModules.has(layer))
            virtualModuleContent = def(compiler.$windi.virtualModules.get(layer), "");
        }
        virtualModules.writeModule(
          join(this.options.virtualModulePath, virtualModulePath),
          `/* windicss(hmr:${moduleUpdateId}:${resource}) */
${virtualModuleContent}`
        );
      });
    };
    compiler.hooks.invalid.tap(NAME, (resource) => {
      if (!resource)
        resource = "all-modules";
      if (!compiler.$windi || shouldExcludeResource(resource))
        return;
      const skipInvalidation = compiler.$windi.dirty.has(resource) || resource !== "all-modules" && !compiler.$windi.isDetectTarget(resource) && resource !== compiler.$windi.configFilePath;
      debug.plugin("file update", resource, `skip:${skipInvalidation}`);
      if (skipInvalidation)
        return;
      compiler.$windi.dirty.add(resource);
      invalidateCssModules(resource, MODULE_ID_VIRTUAL_MODULES);
    });
    const initWindyCSSService = async () => {
      if (!compiler.$windi) {
        const utils = def(this.options.utils, createUtils(this.options, {
          root,
          name: NAME
        }));
        compiler.$windi = Object.assign(
          utils,
          {
            root,
            virtualModules: /* @__PURE__ */ new Map(),
            dirty: /* @__PURE__ */ new Set(),
            invalidateCssModules,
            server: new Server(compiler, this.options.server)
          }
        );
        try {
          await compiler.$windi.init();
        } catch (e) {
          compiler.$windi.initException = e;
        }
      }
    };
    compiler.hooks.thisCompilation.tap(NAME, (compilation) => {
      if (!compiler.$windi)
        return;
      if (compiler.$windi.initException) {
        compilation.errors.push(compiler.$windi.initException);
        compiler.$windi.initException = void 0;
      }
      compilation.hooks.childCompiler.tap(NAME, (childCompiler) => {
        childCompiler.$windi = compiler.$windi;
      });
    });
    compiler.hooks.beforeCompile.tapPromise(NAME, async () => {
      await initWindyCSSService();
    });
    compiler.hooks.watchRun.tapPromise(NAME, async () => {
      await initWindyCSSService();
    });
  }
}

export { WindiCSSWebpackPlugin as default };
