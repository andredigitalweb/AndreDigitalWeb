'use strict';

const pluginUtils = require('@windicss/plugin-utils');
const pathe = require('pathe');
const VirtualModulesPlugin = require('webpack-virtual-modules');
const utils = require('./shared/windicss-webpack-plugin.5973fca3.cjs');
const http = require('http');
const path = require('path');
require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const VirtualModulesPlugin__default = /*#__PURE__*/_interopDefaultLegacy(VirtualModulesPlugin);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);

const getPort = (options) => import('get-port').then(({ default: getPort2 }) => getPort2(options));
function getBodyJson(req) {
  return new Promise((resolve2, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve2(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
function updateCSS(compiler) {
  const names = utils.getChangedModuleNames(compiler.$windi);
  compiler.$windi.dirty.add(path.resolve(__dirname, "./core/dev-tools-update.js"));
  compiler.$windi.invalidateCssModules(utils.DEVTOOLS_VIRTUAL_MODULE, names);
}
class Server {
  constructor(compiler, options) {
    var _a, _b;
    this.host = (_a = options == null ? void 0 : options.host) != null ? _a : utils.DEFAULT_SERVER_HOST;
    this.port = (_b = options == null ? void 0 : options.port) != null ? _b : utils.DEFAULT_SERVER_PORT;
    this.server = http__default.createServer(async (req, res) => {
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type");
      if (req.url === utils.DEVTOOLS_POST_PATH && req.method === "POST") {
        try {
          const data = await getBodyJson(req);
          let changed = false;
          switch (data.type) {
            case "add-classes":
              changed = compiler.$windi.addClasses(data.data || []);
          }
          if (changed && this._listen)
            updateCSS(compiler);
          res.statusCode = 200;
          res.end();
        } catch (err) {
          res.statusCode = 500;
          res.end();
        }
      } else {
        res.statusCode = 200;
        res.end();
      }
    });
    this._listen = false;
  }
  async ensureStart() {
    if (!this._listen && utils.isDev()) {
      this.port = await getPort({ port: this.port });
      this.server.listen(this.port, this.host, () => {
        this._listen = true;
        process.once("exit", () => {
          this.close();
        });
      });
    }
    return this;
  }
  close() {
    if (this._listen)
      this.server.close();
  }
}

const loadersPath = pathe.resolve(__dirname, "loaders");
const pitcher = pathe.resolve(loadersPath, "windicss-style-pitcher.cjs");
const transformCSSLoader = pathe.resolve(loadersPath, "windicss-css.cjs");
const transformTemplateLoader = pathe.resolve(loadersPath, "windicss-template.cjs");
const virtualModuleLoader = pathe.resolve(loadersPath, "virtual-module.cjs");
const devtoolsLoader = pathe.resolve(loadersPath, "dev-tools.cjs");
class WindiCSSWebpackPlugin {
  constructor(options = {}) {
    this.options = {
      ...{
        virtualModulePath: ""
      },
      ...options
    };
  }
  apply(compiler) {
    let root = compiler.context;
    if (this.options.root)
      root = this.options.root;
    else if (compiler.options.resolve && compiler.options.resolve.alias && compiler.options.resolve.alias["~"])
      root = compiler.options.resolve.alias["~"];
    if (!compiler.options.module || !compiler.options.module.rules)
      return;
    if (!compiler.options.resolve)
      compiler.options.resolve = {};
    compiler.options.resolve.alias = {
      ...compiler.options.resolve.alias,
      [pathe.join(this.options.virtualModulePath, utils.MODULE_ID)]: pathe.resolve(compiler.context, utils.MODULE_ID_VIRTUAL_MODULES[0]),
      [pathe.join(this.options.virtualModulePath, utils.DEVTOOLS_MODULE_ID)]: pathe.resolve(compiler.context, utils.DEVTOOLS_VIRTUAL_MODULE),
      [pathe.join(this.options.virtualModulePath, utils.DEVTOOLS_VIRTUAL_MODULE_ID)]: pathe.resolve(compiler.context, utils.DEVTOOLS_VIRTUAL_MODULE),
      ...utils.MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
        map[pathe.join(this.options.virtualModulePath, key)] = pathe.resolve(compiler.context, key);
        return map;
      }, {}),
      ...utils.MODULE_ID_VIRTUAL_MODULES.reduce((map, key) => {
        map[pathe.join(this.options.virtualModulePath, key.replace("virtual:", ""))] = pathe.resolve(compiler.context, key);
        return map;
      }, {})
    };
    utils.debug.plugin("options", this.options);
    compiler.options.module.rules = compiler.options.module.rules.map((rule) => {
      if (!rule.use || !Array.isArray(rule.use))
        return rule;
      rule.use = rule.use.map((use) => {
        if (use === "css-loader") {
          return {
            loader: "css-loader",
            options: {
              importLoaders: 2
            }
          };
        }
        return use;
      });
      return rule;
    });
    const shouldExcludeResource = (resource) => utils.MODULE_ID_VIRTUAL_TEST.test(resource);
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isDetectTarget(resource));
      },
      resourceQuery: /type=style/,
      enforce: "post",
      use: [{
        loader: pitcher
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isDetectTarget(resource));
      },
      use: [{
        loader: transformTemplateLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        if (!compiler.$windi || shouldExcludeResource(resource))
          return false;
        return Boolean(compiler.$windi.isCssTransformTarget(resource));
      },
      use: [{
        loader: transformCSSLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        return utils.MODULE_ID_VIRTUAL_TEST.test(resource);
      },
      enforce: "pre",
      use: [{
        loader: virtualModuleLoader
      }]
    });
    compiler.options.module.rules.push({
      include(resource) {
        return resource.includes(utils.DEVTOOLS_VIRTUAL_MODULE);
      },
      enforce: "pre",
      use: [{
        loader: devtoolsLoader
      }]
    });
    compiler.hooks.afterCompile.tap(utils.NAME, (compilation) => {
      if (!compiler.$windi)
        return;
      if (compiler.$windi.configFilePath) {
        const configFilePath = pathe.resolve(compiler.$windi.configFilePath);
        utils.debug.plugin("config dependency at", configFilePath);
        compilation.fileDependencies.add(configFilePath);
      } else {
        for (const name of ["windi.config.ts", "windi.config.js"]) {
          const path = pathe.resolve(root, name);
          utils.debug.plugin("setting watcher for config creation", path);
          compilation.missingDependencies.add(path);
        }
      }
    });
    const virtualModules = new VirtualModulesPlugin__default(
      [...utils.MODULE_ID_VIRTUAL_MODULES, utils.DEVTOOLS_VIRTUAL_MODULE].reduce((map, key) => {
        map[pathe.join(this.options.virtualModulePath, key)] = `/* ${key}(boot) */`;
        return map;
      }, {})
    );
    virtualModules.apply(compiler);
    let hmrId = 0;
    const invalidateCssModules = (resource, modules) => {
      const moduleUpdateId = hmrId++;
      modules.forEach((virtualModulePath) => {
        let virtualModuleContent = "";
        const match = virtualModulePath.match(utils.MODULE_ID_VIRTUAL_TEST);
        if (match) {
          const layer = match[1] || "all";
          if (compiler.$windi && compiler.$windi.virtualModules.has(layer))
            virtualModuleContent = utils.def(compiler.$windi.virtualModules.get(layer), "");
        }
        virtualModules.writeModule(
          pathe.join(this.options.virtualModulePath, virtualModulePath),
          `/* windicss(hmr:${moduleUpdateId}:${resource}) */
${virtualModuleContent}`
        );
      });
    };
    compiler.hooks.invalid.tap(utils.NAME, (resource) => {
      if (!resource)
        resource = "all-modules";
      if (!compiler.$windi || shouldExcludeResource(resource))
        return;
      const skipInvalidation = compiler.$windi.dirty.has(resource) || resource !== "all-modules" && !compiler.$windi.isDetectTarget(resource) && resource !== compiler.$windi.configFilePath;
      utils.debug.plugin("file update", resource, `skip:${skipInvalidation}`);
      if (skipInvalidation)
        return;
      compiler.$windi.dirty.add(resource);
      invalidateCssModules(resource, utils.MODULE_ID_VIRTUAL_MODULES);
    });
    const initWindyCSSService = async () => {
      if (!compiler.$windi) {
        const utils$1 = utils.def(this.options.utils, pluginUtils.createUtils(this.options, {
          root,
          name: utils.NAME
        }));
        compiler.$windi = Object.assign(
          utils$1,
          {
            root,
            virtualModules: /* @__PURE__ */ new Map(),
            dirty: /* @__PURE__ */ new Set(),
            invalidateCssModules,
            server: new Server(compiler, this.options.server)
          }
        );
        try {
          await compiler.$windi.init();
        } catch (e) {
          compiler.$windi.initException = e;
        }
      }
    };
    compiler.hooks.thisCompilation.tap(utils.NAME, (compilation) => {
      if (!compiler.$windi)
        return;
      if (compiler.$windi.initException) {
        compilation.errors.push(compiler.$windi.initException);
        compiler.$windi.initException = void 0;
      }
      compilation.hooks.childCompiler.tap(utils.NAME, (childCompiler) => {
        childCompiler.$windi = compiler.$windi;
      });
    });
    compiler.hooks.beforeCompile.tapPromise(utils.NAME, async () => {
      await initWindyCSSService();
    });
    compiler.hooks.watchRun.tapPromise(utils.NAME, async () => {
      await initWindyCSSService();
    });
  }
}

module.exports = WindiCSSWebpackPlugin;
