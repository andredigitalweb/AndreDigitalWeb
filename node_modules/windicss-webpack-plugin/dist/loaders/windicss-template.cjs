'use strict';

const compileTemplate = require('lodash/template');
const defaults = require('lodash/defaults');
const loaderUtils = require('loader-utils');
const utils = require('../shared/windicss-webpack-plugin.5973fca3.cjs');
require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const compileTemplate__default = /*#__PURE__*/_interopDefaultLegacy(compileTemplate);
const defaults__default = /*#__PURE__*/_interopDefaultLegacy(defaults);
const loaderUtils__default = /*#__PURE__*/_interopDefaultLegacy(loaderUtils);

function WindicssTemplate(source) {
  if (!this._compiler)
    return source;
  this.cacheable(true);
  const service = this._compiler.$windi;
  if (!service)
    return source;
  if (this.resource.indexOf("type=style") > 0)
    return utils.transformCSS(service, source, this.resource);
  const hasHtmlWebpackPlugin = this.loaders.filter((loader) => {
    return loader.loader && loader.loader.indexOf("html-webpack-plugin") > 0 || loader.path && loader.path.indexOf("html-webpack-plugin") > 0;
  }).length > 0;
  if (hasHtmlWebpackPlugin) {
    const options = this.query !== "" ? loaderUtils__default.parseQuery(this.query) : {};
    const template = compileTemplate__default(source, defaults__default(options, { variable: "data" }));
    return `var _ = require(${loaderUtils__default.stringifyRequest(this, `!!${require.resolve("lodash")}`)});module.exports = function (templateParams) { with(templateParams) {return (${template.source})();}}`;
  }
  let output = source;
  try {
    const templateWithTransformedCSS = source.replace(/<style(.*?)>(.*?)<\/style>/gms, (match, meta, css) => {
      if (meta.includes("sass") || meta.includes("stylus") || meta.includes("less")) {
        utils.debug.loader("Template has unsupported block, skipping resource", this.resource);
        return match;
      }
      if (utils.isJsx(css)) {
        let m, transformedCSS2;
        const jsxMatcher = /{`(.*)`}/gms;
        while ((m = jsxMatcher.exec(css)) !== null) {
          if (m.index === jsxMatcher.lastIndex)
            jsxMatcher.lastIndex++;
          m.forEach((match2, groupIndex) => {
            if (groupIndex === 1) {
              const transformedJSXCSS = utils.transformCSS(service, match2, this.resource);
              transformedCSS2 = `<style${meta}>
{\`${transformedJSXCSS}
\`}</style>`;
              utils.debug.loader("jsx transformed", transformedCSS2);
            }
          });
        }
        return utils.def(transformedCSS2, match);
      }
      const transformedCSS = utils.transformCSS(service, css, this.resource);
      return `<style${meta}>
${transformedCSS}
</style>`;
    });
    utils.debug.loader("Transformed template ", this.resource);
    const transformed = service.transformGroups(templateWithTransformedCSS);
    if (transformed)
      output = transformed.code;
    else
      output = templateWithTransformedCSS;
  } catch (e) {
    this.emitWarning(`[WindiCSS] Failed to transform groups and css for template: ${this.resource}.`);
  }
  return output;
}

module.exports = WindicssTemplate;
