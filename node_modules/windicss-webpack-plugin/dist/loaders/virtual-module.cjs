'use strict';

const fs = require('fs');
const pluginUtils = require('@windicss/plugin-utils');
const utils = require('../shared/windicss-webpack-plugin.5973fca3.cjs');
require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

async function VirtualModule(source) {
  const callback = this.async();
  if (!this._compiler) {
    callback(null, source);
    return;
  }
  this.cacheable(false);
  const service = this._compiler.$windi;
  const match = this.resource.match(utils.MODULE_ID_VIRTUAL_TEST);
  if (!service || !match) {
    const error = new Error(`Failed to match the resource "${this.resource}" to a WindiCSS virtual module.`);
    this.emitError(error);
    callback(error, source);
    return;
  }
  const layer = match[1] || void 0;
  const isBoot = source.indexOf("(boot)") > 0;
  utils.debug.loader(`Generating "${this.resource}" using layer "${layer}${isBoot ? '" as boot ' : " as hmr"}`);
  const generateCSS = async (layer2) => {
    try {
      if (service.scanned && service.options.enableScan)
        service.options.enableScan = false;
      const css = (await service.generateCSS(layer2)).replace("(boot)", "");
      service.virtualModules.set(utils.def(layer2, "all"), css);
      callback(null, css);
    } catch (e) {
      const error = JSON.stringify(e, null, 2);
      this.emitError(`[Windi CSS] Failed to generate CSS. Error: ${error}`);
      callback(e, `${source}
/* Error: ${error}*/`);
    }
  };
  if (isBoot) {
    await generateCSS(layer);
    return;
  }
  const dirtyFiles = Array.from(service.dirty);
  if (dirtyFiles.length === 0) {
    callback(null, source);
    return;
  }
  if (service.dirty.has("all-modules")) {
    const contents = await Promise.all(
      [...await service.getFiles()].filter((id) => service.isDetectTarget(id)).map(async (id) => [await fs__default.promises.readFile(id, "utf-8"), id])
    );
    await Promise.all(contents.map(
      async ([content, id]) => {
        if (service.isCssTransformTarget(id))
          return service.transformCSS(content, id);
        else
          return service.extractFile(content, id, true);
      }
    ));
  } else {
    const configFileUpdated = dirtyFiles.filter((id) => {
      return pluginUtils.defaultConfigureFiles.filter((config) => {
        return id.endsWith(config);
      }).length > 0;
    }).length > 0;
    if (configFileUpdated) {
      service.clearCache();
      await service.init();
    } else {
      const contents = await Promise.all(
        dirtyFiles.map((id) => {
          return {
            data: fs.readFileSync(id, { encoding: "utf-8" }),
            id
          };
        })
      );
      for (const content of contents) {
        try {
          await service.extractFile(content.data, content.id, service.options.transformGroups);
        } catch (e) {
          this.emitWarning(`[Windi CSS] Failed to extract classes from resource: ${content.id}.`);
        }
      }
    }
  }
  service.dirty.clear();
  await generateCSS(layer);
}

module.exports = VirtualModule;
